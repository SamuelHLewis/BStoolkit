#!/usr/bin/env python3

import os
from os import system, listdir, remove
import sys
import subprocess
import shutil
import re
import argparse
import pandas as pd
import numpy as np
from Bio import SeqIO

#######################
## DEFAULT ARGUMENTS ##
#######################
RNAseq_file = False
piRNA_file = False
siRNA_file = False
fasta_file = False

###########################
## USER ARGUMENT PARSING ##
###########################
parser = argparse.ArgumentParser(description='Read arguments')
parser.add_argument('-a', '--annotation', type=str, help='Annotation file for features of interest (gff format)')
parser.add_argument('-m', '--methylation', type=str, help='Methylation levels file (.output file as generated by MethylExtract)')
parser.add_argument('-r', '--RNAseq', type=str, help='RNAseq alignment file (bam format)')
parser.add_argument('-p', '--piRNA', type=str, help='piRNA alignment file (bam format)')
parser.add_argument('-s', '--siRNA', type=str, help='siRNA alignment file (bam format)')
parser.add_argument('-f', '--fasta', type=str, help='genome sequence file (fasta format)')
args = parser.parse_args()
# annotation file parsing
annotation_file = args.annotation
if annotation_file is not None:
	print("Annotation file is " + annotation_file)
else:
	print("ERROR: no annotation file (-a) specified")
	sys.exit(0)
# methylation file parsing
methylation_file = args.methylation
if methylation_file is not None:
	print("Methylation file is " + methylation_file)
else:
	print("ERROR: no methylation file (-m) specified")
	sys.exit(0)
# RNAseq file parsing
if args.RNAseq is not None:
	RNAseq_file = args.RNAseq
	print("RNAseq file is " + RNAseq_file)
else:
	print("No RNAseq file (-r) specified, so RNAseq read count will not be generated")
# piRNA file parsing
if args.piRNA is not None:
	piRNA_file = args.piRNA
	print("piRNA file is " + piRNA_file)
else:
	print("No piRNA file (-p) specified, so piRNA count will not be generated")
# siRNA file parsing
if args.siRNA is not None:
	siRNA_file = args.siRNA
	print("siRNA file is " + siRNA_file)
else:
	print("No siRNA file (-s) specified, so siRNA count will not be generated")
# fasta file parsing
if args.fasta is not None:
	fasta_file = args.fasta
	print("fasta file is " + fasta_file)
else:
	print("No fasta file (-f) specified, so CpG % will not be generated")

##########################
## FUNCTION DEFINITIONS ##
##########################

# function to take a line from a MethyExtract output file, and return a bed-formatted line with % methylation on both strands
def ME_converter(line):
	Line = line.split()
	Chromosome = Line[0]
	Start = str(int(Line[1])-1)
	End = str(int(Line[1])+1)
	Name = "m"+Line[2]
	# note: "Score" here is the mean of the % methylated reads on both strands
	Score = str((((int(Line[3])/int(Line[4]))*100)+((int(Line[6])/int(Line[7]))*100))/2)
	bed_line = Chromosome + "\t" + Start + "\t" + End + "\t" + Name + "\t" + Score
	return(bed_line)

# function to take a MethylExtract output file and output a bed file
def ME_to_BED(ME_file):
	# read input file, keep only lines with methylation called on both strands
	both_strands = []
	for line in open(ME_file, "r"):
		if not line.startswith("#"):
			temp = line.split("\t")
			if not "." in temp:
				both_strands.append(line.strip("\n"))

	# convert lines to bed format
	bed_format_lines = []
	for i in both_strands:
		bed_format_lines.append(ME_converter(i))

	# format output bed file
	bed_output = ""
	for i in bed_format_lines:
		bed_output += i + "\n"
	# output bed file to current working dir, but keep file name
	bed_outfile_name = ME_file.split("/")[-1].replace(".output",".bed")
	bed_outfile = open(bed_outfile_name,"wt")
	bed_outfile.write(bed_output)
	bed_outfile.close()
	return(bed_outfile_name)

# function to take a bed file of methylation levels for cytosines and a gff feature file, and generate mean methylation levels for each feature
def Feature_Meth(meth_bed,GFF):
	# remove path from input filenames (to allow adjusted versions to be written to working directory)
	meth_bed_input = meth_bed.split("/")[-1]
	GFF_input = GFF.split("/")[-1]
	# sort bedfile and feature files
	system("bedtools sort -i " + meth_bed + " > " + meth_bed_input.replace(".bed",".sorted.bed"))
	system("bedtools sort -i " + GFF + " > " + GFF_input.replace(".gff",".sorted.gff"))
	# generate mean methylation levels for each feature, and print the levels for each cytosine used to calculate mean
	system("bedtools map -a " + GFF_input.replace(".gff",".sorted.gff") + " -b " + meth_bed_input.replace(".bed",".sorted.bed") + " -c 5 -o collapse,mean > " + GFF_input.replace(".gff",".CG.bed"))
	# remove intermediate files
	remove(meth_bed_input.replace(".bed",".sorted.bed"))
	remove(GFF_input.replace(".gff",".sorted.gff"))
	print("Methylation levels for " + GFF_input + " written to " + GFF_input.replace(".gff",".CG.bed"))
	return(GFF_input.replace(".gff",".CG.bed"))

# function to calculate CpG content within each feature of an annotation file
def CpG_content(annotation, fasta):
	# extract the sequences for the features of interest
	cmd = "bedtools getfasta -s -fi " + fasta + " -bed " + annotation + " -fo temp.fasta"
	subprocess.call(cmd,shell=True)
	# for each feature, calculate the total and % CpG content
	CpG_totals = []
	CpG_percentages = []
	for record in SeqIO.parse("temp.fasta", "fasta"):
		CpG_total = str(len(re.findall("CG", str(record.seq))))
		CpG_totals.append(CpG_total)
		CpG_percentage = str((len(re.findall("CG", str(record.seq))))/(len(str(record.seq))/2)*100)
		CpG_percentages.append(CpG_percentage)
	return(CpG_percentages)

#################
## ACTUAL CODE ##
#################
# convert MethylExtract file to BED file
input_bed = ME_to_BED(ME_file=methylation_file)

# calculate mean methylation level for each feature in annotation file, and delete whole-genome bed file
meth_levels = Feature_Meth(meth_bed=input_bed,GFF=annotation_file)
remove(input_bed)
# read in methylation levels
meth_counts = pd.read_table(meth_levels, header = None)

# if fasta file has been specified, calculate CpG % in each feature
if fasta_file != False:
	# before running, check whether the fasta index exists, and delete it if so (if the index exists but is older than the fasta file, any changes to the fasta file will break the program, so the index needs to be made afresh)
	if os.path.isfile(fasta_file + ".fai") is True:
		os.remove(fasta_file + ".fai")
	print("Calculating CpG %")
	CpG_percentage = CpG_content(annotation = annotation_file, fasta = fasta_file)

# if RNAseq file has been specified, count and read in RNAseq reads
if RNAseq_file != False:
	print("Counting RNAseq reads")
	system("bedtools coverage -s -counts -a " + annotation_file + " -b " + RNAseq_file + " > RNA.count")
	RNA_counts = pd.read_table("RNA.count", header = None)

# if siRNA file has been specified, count and read in siRNAs
if siRNA_file != False:
	print("Counting siRNAs")
	system("bedtools coverage -counts -a " + annotation_file + " -b " + siRNA_file + " > siRNA.count")
	siRNA_counts = pd.read_table("siRNA.count", header = None)

# if piRNA file has been specified, count and read in piRNAs
if piRNA_file != False:
	print("Counting piRNAs")
	system("bedtools coverage -counts -a " + annotation_file + " -b " + piRNA_file + " > piRNA.count")
	piRNA_counts = pd.read_table("piRNA.count", header = None)

# depending on which bam files have been specified, paste counts onto methylation levels and add header
combined_data = pd.concat([meth_counts], axis = 1)
combined_data.columns = ["Chromosome", "Program", "Feature", "Start", "End", "INTENTIONALLYBLANK", "Strand", "INTENTIONALLYBLANK", "Name", "IndividualCytosineMethylation", "MeanMethylation"]
if fasta_file != False:
	combined_data["CpG (%)"] = CpG_percentage
if RNAseq_file != False:
	combined_data["RNASeq"] = RNA_counts.iloc[:,-1]
if siRNA_file != False:
	combined_data["siRNA"] = siRNA_counts.iloc[:,-1]
if piRNA_file != False:
	combined_data["piRNA"] = piRNA_counts.iloc[:,-1]

# output to file
combined_data.to_csv("Concatenated.counts", sep = "\t", index = False)
print("Combined output written to Concatenated.counts")

# remove intermediate files
cwd = os.getcwd()
directory_contents = listdir(cwd)
for entry in directory_contents:
	if entry.endswith(".count"):
		remove(os.path.join(cwd, entry))
	elif entry.endswith(".sorted.bed"):
		remove(os.path.join(cwd, entry))
	elif entry.endswith(".sorted.gff"):
		remove(os.path.join(cwd, entry))
	elif entry == os.path.join(cwd,"temp.fasta"):
		remove(os.path.join(cwd,"temp.fasta"))

